# MySQL架构

    服务层
        Server 层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
    存储引擎层
        存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB。

# MySQL Select的执行流程

    1、连接MySQL服务
        一、与客户端进行 TCP 三次握手建立连接；
        二、校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
        三、如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；
    2、查询缓存（在MySQL8.0，该功能被废除）
        以查询语句为key，结果为value，缓存在内存中的数据。对该表进行更新，则该表的所有缓存清空。
    3、解析SQL
        解析器会做如下两件事情。
            第一件事情，词法分析。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token,分别为：select、username、from、userinfo，其中有2个Keyword，分别为select、from。
            第二件事情，语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。
    4、执行SQL
        每条SELECT查询语句流程主要可以分为下面这三个阶段：
            prepare 阶段，也就是预处理阶段；
            optimize 阶段，也就是优化阶段；
            execute 阶段，也就是执行阶段；
        一、预处理器做的事情：
            检测表、列等是否存在，不存在则报错。
            优化*为表的所有列名。
        二、优化器做的事情
            优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。
        三、执行器做的事情
            在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。

# MySQL执行器和存储引擎的交互过程

    1、主键索引查询
        该查询使用到索引，在存储引擎层就通过索引判断了是否符合条件，从而快速查询数据并返回。

        以select * from product where id = 1为例，其中id为主键。select * from product where id = 1;这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有id相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录。
        一、执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB存储引擎【索引】查询的接口，把条件 id = 1 交给存储引擎，【让存储引擎定位符合条件的第一条记录】。
        二、存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；
        三、执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则回表获取列数据并发送给客户端，如果不符合则跳过该记录。
        四、执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，也就是查询一条记录，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。
    2、全表扫描
        该查询没有使用到索引，在存储引擎没有进行判断，而是读取数据返回到服务层，交给服务来判断。

        以select * from product where name = 'iphone'为例，其中name没有建立唯一索引，所以是允许重复的。所以采用all查询，可以查询到多条记录。
        一、执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，让存储引擎读取表中的第一条记录（这里没有判断数据是否符合条件）；
        二、执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。
        三、执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；
        四、一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；
        五、执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。
    3、索引下推
        在联合索引的时候，把能利用到索引的判断，下推到存储引擎层，提高效率。

        以select * from t_user  where age > 20 and reward = 100000为例，其中age和reward为联合索引。但是该查询只有age能利用到联合索引。
            1、没有索引下推，那么reward的判断，需要回到服务层，通过主键回表后，获取记录，再对reward进行判断。
            2、索引下推，则在存储引擎层利用联合索引的b+树，快速定位了age>20的索引，再判断是否满足reward。这样减少了回表的次数，提高了效率。
        一、Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；
        【二、不使用索引下推情况下】，存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后进行回表操作，将完整的记录返回给 Server 层。Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；
        【二、使用索引下推情况下】，存储引擎根据二级索引的 B+ 树快速定位到这条记录后，先不执行回表操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给 Server 层。Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。
        三、如此往复，直到存储引擎把表中的所有记录读完。

# MySQL一行记录的存储结构

    表空间,用来存储一个表的数据,表空间由段（segment）、区（extent）、页（page）、行（row）组成.
        段：段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。
            索引段：存放 B + 树的非叶子节点的区的集合；
            数据段：存放 B + 树的叶子节点的区的集合；
            回滚段：存放的是回滚数据的区的集合，之前讲事务隔离 (opens new window)的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。
        区：顺序存放页，默认1MB。
            在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。
        页：顺序存放行。InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。默认为16KB。
        行：数据行。
    行格式（row_format），就是一条记录的存储结构。
        InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。
    Compact行存放数据格式
        1、变长字段长度列表
        2、NULL值列表
            当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了，可以节约空间。
        3、记录头信息，重要的3个字段：
            delete_mask ：标识此条数据是否被删除。
            next_record：下一条记录的位置。
            record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录
        4、row_id
            如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。
        5、trx_id
            事务id，表示这个数据是由哪个事务生成的。
        6、roll_pointer
            这条记录上一个版本数据的指针。用以实现事务。
        7、n个列的值

# B+树的优点

    

# MySQL常用词解释

    1、回表
        查找二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。
    2、覆盖索引
        也就是索引能够覆盖整个查询。以select id from product where product_no = '0002'为例，product_no建立了索引。id可以在product_no的索引上查询到，就可以不做回表操作。
    99、show processlist
        查询客户端连接
        