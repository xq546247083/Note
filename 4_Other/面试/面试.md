# 面试题

## C#程序内存构成

    C#程序的内存架构由多个部分组成，主要依赖于公共语言运行时（CLR）的管理机制。以下是详细的分点总结：
    1、栈（Stack）
        线程私有：每个线程拥有独立的栈空间，默认大小通常为1MB（可配置）。
        存储内容：
            - 局部值类型变量（未闭包捕获时）。
            - 方法调用的参数、返回地址及上下文信息。
            - 值类型的对象本身，引用类型的引用地址（指针），静态对象的引用地址（指针），常量对象的引用地址（指针）等
        特点：
            - 自动管理（后进先出），方法结束时栈帧弹出。
            - 栈溢出（如深度递归）会导致`StackOverflowException`，通常无法恢复。
    2、托管堆（Managed Heap）
        CLR管理：由垃圾回收器（GC）自动回收内存。
        分代结构：
            Gen 0：新对象，GC最频繁。
            Gen 1：存活过Gen 0回收的对象。
            Gen 2：长期存活的对象。
        大对象堆（LOH, Large Object Heap）：
            - 存储对象大小≥85KB（如大数组）。
            - GC处理频率低，不压缩（可能导致碎片）。
        存储内容：
            - 引用类型实例（如类对象）。
            - 装箱后的值类型。
            - 闭包捕获的变量（提升到堆的生成类中）。
    3、非托管堆（Unmanaged Heap）
        手动管理：通过`unsafe`代码、`IntPtr`或调用系统API（如`Marshal.AllocHGlobal`）分配。
        典型场景：
            - 与非托管库交互（如文件句柄、数据库连接）。
        风险：需显式释放（如`IDisposable`接口、`using`语句），否则导致内存泄漏。

        高频堆（High-Frequency Heap/Loader Heap）
        存储内容：
            - 类型元数据、方法表、静态变量。
            - 常量（编译时确定的值）。
        特点：
            - 生命周期与应用程序域（AppDomain）绑定，不会被GC回收。
    4、其他内存区域
        代码段：JIT编译后的本地代码。
        应用程序域（AppDomain）：逻辑隔离单元，静态变量在各自AppDomain独立。
    5、特殊场景
        字符串驻留（Interning）：`string`字面量存入进程级的池，避免重复。
        结构体（Struct）：
            - 默认栈分配，若嵌入类中则存于堆。
            - 显式内存布局可通过`StructLayout`定制（如与非托管代码交互）。
    6、内存管理注意事项
        GC优化：短生命周期对象应避免晋升到Gen 2。
        内存泄漏：
            - 静态集合长期持有对象引用。
            - 未释放非托管资源（需实现`IDisposable`）。
        性能权衡：值类型减少堆分配，但需避免过度装箱。

## NetFramework升级NetCore 8的经验

    1、VS自带的项目升级
    2、基础框架修改为netstandard2.0
    3、处理包引用、ASPCore不兼容的地方、数据库不兼容的地方
    4、优化跨平台的发包方式

##  list、hashset 

    当然，`List` 和 `HashSet` 是常见的数据结构，它们在不同的编程语言中都有实现。以下是对它们的详细介绍，包括它们的原理和特点。
    1. List
        `List` 是一种线性数据结构，用于存储有序的元素集合。它可以动态扩展或缩小，以适应元素数量的变化。
        特点
        - 有序性：元素按照插入顺序排列。
        - 允许重复：可以存储重复的元素。
        - 支持索引访问：可以通过索引快速访问或修改元素。
        - 动态扩展：可以根据需要自动调整大小。
        实现原理
        - 基于数组的实现（如 ArrayList）：
        - 内部使用一个动态数组来存储元素。
        - 当数组容量不足时，会创建一个更大的数组，并将原有元素复制到新数组中。
        - 插入和删除操作在数组中间位置时效率较低，因为需要移动大量元素。
        - 基于链表的实现（如 LinkedList）：
        - 内部使用双向链表来存储元素。
        - 每个节点包含一个元素和两个指针（指向前后节点）。
        - 插入和删除操作在链表中间位置时效率较高，因为只需调整指针即可。
        适用场景
        - ArrayList：适合需要频繁随机访问的场景，如需要按索引快速查找或修改元素。
        - LinkedList：适合需要频繁插入和删除的场景，如频繁在列表中间插入或删除元素。
    1. HashSet
        `HashSet` 是一种基于哈希表的集合数据结构，用于存储无序的、唯一的元素集合。
        特点
        - 无序性：元素没有固定的顺序。
        - 唯一性：不允许存储重复的元素。
        - 快速查找：通过哈希函数实现高效的查找、插入和删除操作。
        实现原理
        - 基于哈希表：
        - 内部使用一个哈希表来存储元素。
        - 每个元素通过哈希函数计算出一个哈希值，该哈希值决定了元素在哈希表中的存储位置（称为“桶”）。
        - 如果两个元素的哈希值相同（称为“哈希冲突”），通常使用链表或开放寻址法来解决冲突。
        - 哈希冲突解决方法：
        - 链表法：每个桶存储一个链表，冲突的元素被存储在同一个链表中。
        - 开放寻址法：当发生冲突时，按照某种探测规则（如线性探测）寻找下一个可用的桶。
        适用场景
        - 需要快速判断某个元素是否存在。
        - 需要存储唯一值的集合。
        - 不关心元素的顺序。
    总结
    - List：适合需要有序存储和频繁随机访问的场景。
    - HashSet：适合需要快速查找和存储唯一值的场景。

## 如何维护线程安全？ concurrentbag 类做法是怎么样的？

    1. 线程安全的维护
        在多线程编程中，维护线程安全是确保数据一致性的重要任务。以下是常见的线程安全维护方法：
        - 锁机制：通过 `lock` 或 `Monitor` 确保同一时间只有一个线程访问共享资源。
        - 无锁编程：使用原子操作（如 `Interlocked`）避免锁的开销。
        - 线程本地存储：每个线程独立操作自己的数据，减少竞争。
        - 不可变性：使用不可变对象确保线程安全。
        - 线程安全集合：使用专门设计的线程安全集合类（如 `ConcurrentBag`）。
    2. `ConcurrentBag` 的实现原理
        `ConcurrentBag` 是 .NET 提供的一种线程安全的集合类，专为多线程场景设计。它的主要特点和实现原理如下：
        - 无序性：`ConcurrentBag` 不保证元素的插入顺序，`TryTake` 方法可能返回任意元素。
        - 线程安全：通过线程本地存储（Thread-Local Storage）实现高效并发。每个线程维护自己的局部队列，减少跨线程竞争。
        - 工作窃取：当一个线程的局部队列为空时，它可以从其他线程的队列中“窃取”任务，提高 CPU 利用率。
        - 无锁设计：内部使用无锁技术（如原子操作）确保高性能。
       1. 典型应用场景
          - 工作窃取模式：多个线程共享任务池，空闲线程从其他线程的任务队列中窃取任务。
          - 临时数据收集：并行计算中，各线程生成的中间结果可以安全地添加到 `ConcurrentBag` 中。
       2. 注意事项
          - 无序性：`ConcurrentBag` 不保证元素顺序，适合不需要顺序的场景。
          - 性能权衡：在频繁跨线程操作的场景中，可能不如 `ConcurrentQueue` 或 `ConcurrentStack` 高效。
          - 空集合处理：`TryTake` 可能失败，需结合循环或超时机制。

## async和await的趣事

    该类用来启动WebSocket客户端，启动时，第一个为和服务循环检测，保持链接，第二个为循环接受消息，在没有连接的时候，跳过本次接受。以前用的Thread，升级到信创后，修改为async的方式，启动上面的2个异步操作。但是，当服务不在线的时候，客户端连接失败，接受消息方法中，先会判断连接是否打开，没有打开，直接进行下一个循环(因为没有进入await client.ReceiveAsync()，堆栈没有返回)，导致启动时，程序卡主。

## async/await

    本质是状态机。
    异步方法的生命周期可以分为以下几个阶段：
        1、初始化：创建状态机实例，初始化状态和任务构建器。
        2、开始执行：调用 Start 方法开始执行异步方法。
        3、执行方法体：在 MoveNext 方法中，根据当前状态执行相应的代码。
        4、遇到 await：检查任务是否完成，如果未完成则注册回调并暂停方法执行。
        5、任务完成：回调被触发，重新调用 MoveNext 方法，恢复异步方法的执行。
        6、方法完成：所有异步操作完成，设置任务的结果或异常。
    这导致await看似是阻塞，实则是回调。

## valuetask

    1、值类型
    2、很多限制，最好只是在await立等结果的地方使用。
    3、一般不使用，在大量的循环中为了性能可能使用。(Task为引用类型，会创建大量的对象在堆上，导致GC压力)

## 什么是 async io,在.net 上表现形式是什么

    什么是异步IO？
        异步IO（Asynchronous I/O）是一种用于优化I/O操作的技术，它允许程序在等待I/O操作完成时不阻塞线程，从而提高系统的响应能力和吞吐量。与传统的同步I/O操作不同，异步I/O操作不会阻塞调用线程，而是在线程等待I/O操作完成时释放线程资源，让线程去执行其他任务。当I/O操作完成时，系统会通知程序，程序可以继续处理结果。
    在.NET上的表现形式
        在.NET中，异步IO主要通过async和await关键字来实现，这些关键字是C#异步编程的核心。从.NET Framework 4.5开始，I/O类型包括了异步方法，以简化异步操作。这些异步方法在其名称中包括Async，例如ReadAsync、WriteAsync、CopyToAsync、FlushAsync、ReadLineAsync和ReadToEndAsync等。

## iocp、epoll

    epoll
        linux使用，通知你来处理任务，回调状态。
    iocp
        win使用，任务完成后，通知你来接受，回调任务。

## 如何将一段内存数据转换为 struct

    Marshal

## GC

    1、模式
        一、工作站模式
            垃圾回收的频率较高，但每次回收的停顿时间较短。
            垃圾回收直接在触发回收的用户线程上执行，与其他用户线程竞争 CPU 时间。
            只分配一个 GC 堆，因此内存分配较少
        二、 服务器模式
            垃圾回收的频率较低，减少停顿时间。
            为每个 CPU 核心分配一个独立的 GC 堆和专用线程，提高吞吐量和性能。
            通常分配更大的内存分段，适合多核心系统
    2、子模式
        后台模式（Background GC）：
            使用专用线程回收第 2 代对象，回收时不会挂起其他线程。
            适用于需要减少停顿时间的场景。
        非并发模式（Non-Concurrent GC）：
            垃圾回收时会挂起所有其他线程，适用于对停顿时间要求不高的场景
    3、抑制GC回收
        GC.TryStartNoGCRegion
    4、查看GC的数量
        Windebug
    5、GC堆的种类
        0、1、2代，以及大对象堆
        分类主要是为了快速回收内存，降低卡顿。生命周期短的对象，在0代被快速回收，生命周期长的进入1、2代，降低0代的数量，增加回收效率。

## 终结器

    终结器（Finalizer）是一种在垃圾回收过程中自动调用的方法，用于执行清理工作。它允许开发者在对象被垃圾回收器回收之前，释放系统资源、关闭文件、断开数据库连接等。
    使用场景
        终结器主要用于释放非托管资源，如文件句柄、数据库连接等。这些资源需要显式的清理，而垃圾回收器不知道如何处理它们。
    使用问题
        执行时间不确定：终结器的执行时间由垃圾回收器决定，无法保证及时性。这可能导致资源释放延迟。
        不能显式调用：终结器只能由垃圾回收器调用，开发者无法控制其执行时间。
        未捕获异常：终结器中抛出的未捕获异常会被忽略，这可能导致程序状态不一致。
        性能开销：终结器的使用会增加垃圾回收的复杂性，降低回收效率。
        安全问题：终结器可能受到终结器攻击，导致恶意子类记录部分构造对象的引用，从而引发安全问题。
    替代方案
        确定性终结：通过实现 IDisposable 接口，显式调用 Dispose 方法来释放资源。
        try-finally 或 try-with-resources：确保资源在异常情况下也能被正确释放。

## 泛型

    泛型的优点
        1、值类型装箱会额外占用内存
        2、装箱/拆箱会消耗额外的CPU
        3、代码复用，简单
    
    泛型的缺点
        1、生成的代码爆炸
        2、优化代码爆炸（按照目前的优化，如果不是大量使用结构体，不会出现生成的代码爆炸）
            1、相同类型实参，共用一套方法
            2、引用类型实参，共用一套方法

## 委托

    1、本质是封装了c++的函数指针，是编译时确保类型安全。
    2、多播是因为存储了invocationList。

## 反射

    1、反射的本质就是“操作元数据”
    2、元数据：存储在dll中的一个信息数据库，记录了这个assembled中有哪些方法，哪些类，哪些属性等等信息，通过ILSpy可以看到由各种Table组成的信息。
    3、反射到底慢在哪？
        动态解析
            从上面可知道，反射作为后期绑定，在runtime中要根据metadata查询出信息，严重依赖字符串匹配，这本身就增加了额外的操作
        动态调用
            使用反射调用方法时，先要将参数打包成数组，再解包到线程栈上。又是额外操作。
        无法在编译时优化
            反射是动态的临时调用，JIT无法优化。只能根据代码一步一步执行。
        额外的安全检查
            调用方法时，进行额外的安全性检查，检查参数类型是否正确。这也会增加一定的开销
        缓存易失效
            反射如果参数发生变化，那么缓存的汇编就会失效。又需要重新查找与解析。
    4、Emit是.NET提供的一种动态生成和编译代码的技术。通过 Emit，我们可以动态生成一个新的方法，这个方法可以直接访问修改私有成员。
    5、Expression是.NET提供的一种表达式树的技术。通过 Expression，我们可以创建一个表达式树，然后编译这个表达式树，生成一个可以访问修改私有成员的方法。
    6、UnsafeAccessorAttribute是.Net 8中引入了新特性。使用该特性，来提供对私有字段的快速修改。
        这个速度很快，原因是：对于C#来说，私有类型是OOP语言的定义。它定义了什么是私有类型，它的行为是什么。但对于程序本身来说，代码和数据都只是一段内存，实际上你的指针想访问哪就访问哪。哪管你什么私有类型。换一个指向地址不就得了。因此CLR开放了这么一个口子，利用外部访问直接操作内存。
        static void New()
        {
            var person = new Person();
            AccessAgeField(person) = 100;
            var age = AccessAgeField(person);
        }
        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_age")]
        static extern ref int AccessAgeField(Person counter);

## 属性

    Attribute对象的很多方法实现是依赖反射。在使用中，使用Dictionary缓存结果集。避免过多调用反射造成的性能问题。

## 线程

    1、Windows下线程的数据结构
        每个线程都有以下要素，这是创建线程无法避免的开销。
        线程内核对象(Thread Kernel Object)
            OS中创建的每一个线程都会分配数据结构来承载描述信息
            Windows会给每一个 Thread 分配一个_ETHREAD的内存结构，用来记录当前线程的状态，其中就包括了线程上下文(Thread Context)
        线程环境块(Thread Environment Block, TEB)
          TEB是在用户态中分配的内存块，主要包括线程的Exception，Local Storage等信息
        用户态线程栈(User-Mode Stack)
            我们常说的栈空间就是指的这里,大名鼎鼎的OOM就出自于此
        内核态线程栈(Kernel-Mode Stack)
            处于安全隔离考虑，在内核态中复制了一个同样的栈空间。用来处理用户态访问内核态的代码。
    2、线程上下文切换的本质
        上下文切换的本质就是，备份被切换线程寄存器的值，到该线程的上下文中。再从切换后的线程中，读取上下文到寄存器中。
    3、ThreadLocal
        TLS是基于C++做的封装，TLS中只存储了一个ThreadLocalInfo对象，最后借助它与Thread的关联。来得知存储在托管堆中的线程本地变量。
    4、AsyncLocal
        C#中每一个线程都会绑定一个ExecutionContext,可以使用Thread.CurrentThread.ExecutionContext来查看。理想情况下，当一个线程使用另一个线程执行任务时，前者的执行ExecutionContext会被copy到后者中来。这个过程被称为上下文流动因此，AsyncLocal能够执行成功秘诀就在于，当线程切换的时候，线程1所存储AsyncTLS流动到了到了线程2。因此线程2能够读取到线程1的值。

## 线程池

    1、线程池执行队列的类型
        全局队列
        低优先级队列
        高优先级队列
        线程本地队列
    2、线程执行优先级
        当线程池Dequeue时，会优先检查本地队列(LIFO)，如果为空就查询高优先级队列，再检查全局队列，再检查低优先级队列。如果检查完低优先级队列还是为空，那么它会"窃取"其它线程的本地队列。需要注意一点的是，当窃取其它线程的任务时，它会使用FIFO顺序来访问，被窃取的线程还是不变使用LIFO。这样一个从头部读取(被窃取的线程)，一个从尾部读取(窃取的线程)。无需同步锁，减少冲突。
    3、本地队列线程的优点
        减少线程竞争，尽量使相同的代码使用一个线程，这样会减少锁等待的概率。
        提高缓存利用率，减少切换线程的缓存数据，因为有些共用的数据。
        工作窃取机制的基础，有本地队列，才有窃取这个说法，防止空线程。
        降低上下文切换成本。
    4、Task
        Task的底层实现主要取决于TaskSchedule，一般来说，除了UI线程外，默认是调度到线程池，也就是本质也是线程池。
    5、Task对线程池的优化
        既然Task的底层是使用ThreadPool,而线程池注入速度是比较慢的。所以当使用Task.Result时，底层会调用InternalWaitCore(),如果Task还未完成,会调用ThreadPool.NotifyThreadBlocked()来通知ThreadPool当前线程已经被阻塞，必须马上注入一个新线程来代替被阻塞的线程。相对每500ms来轮询注入线程，该方式采用事件驱动，注入线程池的速度会更快。

## Async(异步)

    1、异步，适用于"IO密集型"的场景,它可以避免因为线程等待IO形成的线程饥饿，从而造成程序吞吐量的降低。他可以是一个线程实现。IOCP则为异步。
    2、多线程，适用于"CPU密集型",主要是为了更多的利用多核CPU来同时执行逻辑。将一个大任务分而治之，提高完成速度，进而提高程序的并发能力。
    3、异步操作的核心:IO完成端口(IO Completion Port，简称IOCP)
        IO完成端口（IO Completion Port）是Windows操作系统的一个内核对象，专门用来解决异步IO的问题，C#中所有异步操作都依赖此端口。其本质是一个发布订阅模式的队列，CLR在初始化时，创建一个IO Completion Port完成与硬件设备的绑定，使得硬件的驱动程序知道将IRP送到哪里去。
    4、异步的本质是状态机，状态机的核心是：MoveNext函数，一个Task最少要被调用两次MoveNext,第一次调用是主动触发初始化状态机，第二次调用是回调函数再次执行状态机。
    5、Aysnc的异常处理
        当异步操作发生异常时，IO Completion Port会告诉程序，异步操作已经完成，但存在一个错误。不会跟常规异常一样直接从内核态抛出一个异常。因此ThreadPool调用SetException存储起来。当你调用await/GetResult() 或者直接try catch时才会真正的抛出异常。如果都有没有捕获，则异常会被吃掉，导致无法分析错误问题。

## Lock

    1、用户态锁
        优点：
            通常性能较高，因为不需要进行用户态与内核态的切换，避免了切换带来的额外开销，如上下文保存与恢复等。例如在无竞争的情况下，用户态的自旋锁和互斥锁都可以快速地获取和释放锁，执行时间相对较短.
        缺点：
            在高并发竞争激烈的情况下，如果线程长时间获取不到锁，自旋锁会导致 CPU 空转浪费资源，而互斥锁的等待队列管理等也会在用户态消耗一定的 CPU 时间.
    2、内核态锁
        优点：
            内核态锁由操作系统内核管理和调度，当锁被释放时，内核可以及时地唤醒等待的线程，适用于复杂的同步场景和长时间等待的情况.
        缺点：
            由于涉及到用户态与内核态的切换，开销较大，这在锁的竞争不激烈或者临界区执行时间较短时，会对性能产生较大的影响
    3、原子操作适用场景
        一、针对可以重试的情况，如后台任务，如果正在运行，则下一次尝试。
        二、用户点击，可以直接返回，正在运行。
    4、读写锁（ReaderWriterSlim）
        内存中的数据读写
    5、Lock
        同时只能有一个线程访问的情况。
    6、读写锁、Lock
        都是混合锁，其内部由两部分构成，也分别对应不同场景下的用户态与内核态实现。
            自旋锁(Thinlock)：CoreCLR利用Thinlock机制来实现轻量级自旋。
            内核锁(AwareLock):当自旋无效的情况下，会退化为awarelock锁，并用SyncBlock来维护锁信息。
        锁先使用用户态锁自旋一定次数，如果获取不到锁。再转换成内核态锁。从而降低CPU消耗。
    7、锁问题
        1、死锁 你要我的锁，我要你的锁。
        2、孤儿锁 因为异常等情况，没有释放锁。

## CLR堆

    1、加载堆，使用!eeheap -loader可以查看
        主要是供CLR内部使用，作为承载程序的元数据。
        HighFrequencyHeap
            存放CLR高频使用
            之间的继承关系，调用接口的方法和虚方法，都需要访问MethodTable
        LowFrequencyHeap
            存放CLR低频使用的内部数据，比如EEClass,ClassLoader.
            GC信息与异常处理表，它们都只在发生时才访问，因此访问频率不高。
        StringLiteralMap
            字符串驻留池:https://www.cnblogs.com/lmy5215006/p/18494483
            字符串对象本身存储在FOH堆中,String Literal Map只是一个索引
        StubHeap
            函数入口的代码堆
        CodeHeap
            JIT编译代码使用的内部堆，比如生成IL。
        VirtualCallStubHeap
            虚方法调用的内部堆
    2、托管堆，使用!eeheap -gc可以查看
        1、SOH(small object heap)
            1、这个是分代管理
            2、GC升代,不是copy对象从0代到1代。而是移动代的边界。每次GC触发时，代边界指针会在多个“地址段”上迁移，通过这种逻辑操作，优化性能。
            3、每代的清理算法，大致：0代为标记复制，1、2代为标记清理、标记整理。
        2、LOH(large object heap)
        3、POH
            固定对象专属的堆，比如非托管线程访问托管对象，就需要把对象固定起来，避免被GC回收造成非托管代码的访问违例.
        4、FOH（Frozen object heap,又叫NoneGCHeap，冻结堆)
            NET8推出来的一个新堆，用来存放永远不会被GC管理的永生对象，比如string 字面量（literal）。
        5、堆是逻辑概念，物理上由多个内存段(Heap Seg-ment)构成。

## 异常

    1、异常的分类
        用户异常
        硬件异常
    2、异常的实现
        一、记录异常处理表
            一旦方法中有try-catch语句块时，JIT会将try-catch的适用范围记录下来，并整理成异常处理表(Execption Handling Table , EH Table)
        二、捕获异常并抛出异常的位置
            .NET9之前进入内核态利用SEH机制捕获并定位异常，.NET9之后在用户态的异常在托管层自行捕获。
        三、通过线程栈空间获取异常调用栈
            线程的栈空间维护了整个调用栈，扫描整个栈空间即可获取。
        四、获取元数据的异常处理表
            当异常发生时，Runtime会枚举EH Table，找出并调用对应的catch块与finally块。

## C#源码到汇编的过程

    一、C#源码被Roslyn编译器编译成DLL，DLL中包含了MetaData与IL Code。
    二、由加载器（ClassLoader）根据MetaData构建出类型系统的数据结构。
    三、再由JIT编译器根据IL Code，懒加载式的生成汇编等。

## 常用集合的注意事项
    
    1、List.Insert(0, item) 的坑
        List基于数组实现，数组在内存中是连续存储的。当使用 Insert(0, item) 在列表开头插入元素时，列表中现有的所有元素都需要向后移动一个位置，以便为新元素腾出空间。这意味着插入操作的时间复杂度为O(n) ，其中n是列表中现有元素的数量。元素数量越多，移动元素所花费的时间就越长，性能也就越低。
    2、HashSet/Dictionary
        Dictionary<TKey, TValue> 的底层结构主要由以下几个部分组成：
        桶（Bucket）数组：
            这是一个一维数组，数组的每个元素称为一个桶。桶数组的大小是 Dictionary 的容量，初始容量通常是一个较小的质数，后续会根据元素数量的增加而动态调整。
        条目（Entry）数组：每个桶对应一个或多个条目，条目是一个结构体，包含三个重要的字段：
            *. int hashCode：键的哈希码，用于确定键在桶数组中的位置。
            *. int next：指向下一个条目的索引，用于处理哈希冲突。如果该值为 -1，表示这是该桶中的最后一个条目。
            *. TKey key：存储的键。
            *. TValue value：存储的值。
    3、ConcurrentDictionary
        ConcurrentDictionary<TKey, TValue> 的底层核心是由多个分段（Segment）组成，每个分段本质上是一个小型的哈希表，并且每个分段都有自己独立的锁。这种设计将整个字典划分为多个部分，不同线程可以同时访问不同的分段，从而减少锁的竞争，提高并发性能。
    4、ConcurrentQueue
        一、ConcurrentQueue 底层主要基于链表（Linked List）数据结构实现，链表是一种动态的数据结构，由一系列节点（ConcurrentQueueSegment）组成，每个节点包含一个数据元素和一个指向下一个节点的引用。为了保证线程安全，ConcurrentQueue 在链表的基础上使用了无锁（Lock - Free）算法，主要借助原子操作（如 Interlocked 类提供的方法）来避免传统锁带来的性能开销和潜在的死锁问题。
        二、Count操作：不要高频次调用Count属性，因为内部调用逻辑非常复杂，需要遍历每一个Segment的head,tail之间的差值，动态计算出最终的大小，且还有加锁操作，消耗不低。

## AspNetCore管道

    ASP.NET Core 的管道是一系列按顺序调用的请求委托（middleware），用于处理 HTTP 请求和响应。每个委托可以执行一些操作，然后将请求传递给管道中的下一个委托。

## Kestrel

    Kestrel 作为一个高性能的 Web 服务器，使用了许多性能优化技术，如异步 I/O、零拷贝传输、管道（System.IO.Pipelines）等：
        异步 I/O：Kestrel 是一个异步的事件驱动服务器，使用 Task 和 async/await 来处理大量并发连接。
        System.IO.Pipelines：这是一个高效的流处理 API，Kestrel 使用它来减少内存分配和提高吞吐量。
            一、缓冲池的使用：借助Span<byte>来避免重复内存分配，让内存使用更加高效。
            二、缓冲区扩展：当缓冲区数据不足时，通过扩展而不是重新分配，提升了性能。
        连接池：Kestrel 使用连接池来优化大量连接的处理，减少连接创建和销毁的开销。
        基于 .NET Core 的运行时优化：利用 Span<T>、ref struct、ValueTask 等特性减少堆分配，提升内存效率。
        低开销的垃圾回收（GC）：通过对象池（ArrayPool<T>）和 IDisposable 接口主动释放资源，降低 Gen 0 GC 频率。
        中间件管道优化：请求处理管道（Middleware Pipeline）通过 RequestDelegate 链式调用，避免反射和动态分发，提升执行速度。

## Span、Memory

    memory是span的引用版本。他们主要是可以直接访问内存，减少了内存复制的频率。
    优点：
        减少了垃圾回收器的分配次数，还能减少数据副本的数量，为同时处理多个缓冲区提供更有效的方法。
        允许你编写高性能代码。例如，如果有一大块内存需要分割成小块，可以使用 Span 作为原始内存的视图。这样就可以直接访问原始缓冲区中的字节，而无需复制。
        允许直接访问内存而无需复制，这在使用本地库或与其他语言互操作时尤其有用。
        在对性能要求较高的紧凑循环中（如密码学或网络数据包检查），可以省去边界检查。
        可以消除与 List 等通用集合相关的装箱和拆箱成本。

## efcore如何从数据变成对象

    1、第一次查询数据会创建映射关系，并缓存。
    2、根据映射关系，反射对象和赋值。

## 