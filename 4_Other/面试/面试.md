# 面试题

## C#程序内存构成

    C#程序的内存架构由多个部分组成，主要依赖于公共语言运行时（CLR）的管理机制。以下是详细的分点总结：
    1、栈（Stack）
        线程私有：每个线程拥有独立的栈空间，默认大小通常为1MB（可配置）。
        存储内容：
            - 局部值类型变量（未闭包捕获时）。
            - 方法调用的参数、返回地址及上下文信息。
            - 值类型的对象本身，引用类型的引用地址（指针），静态对象的引用地址（指针），常量对象的引用地址（指针）等
        特点：
            - 自动管理（后进先出），方法结束时栈帧弹出。
            - 栈溢出（如深度递归）会导致`StackOverflowException`，通常无法恢复。
    2、托管堆（Managed Heap）
        CLR管理：由垃圾回收器（GC）自动回收内存。
        分代结构：
            Gen 0：新对象，GC最频繁。
            Gen 1：存活过Gen 0回收的对象。
            Gen 2：长期存活的对象。
        大对象堆（LOH, Large Object Heap）：
            - 存储对象大小≥85KB（如大数组）。
            - GC处理频率低，不压缩（可能导致碎片）。
        存储内容：
            - 引用类型实例（如类对象）。
            - 装箱后的值类型。
            - 闭包捕获的变量（提升到堆的生成类中）。
    3、非托管堆（Unmanaged Heap）
        手动管理：通过`unsafe`代码、`IntPtr`或调用系统API（如`Marshal.AllocHGlobal`）分配。
        典型场景：
            - 与非托管库交互（如文件句柄、数据库连接）。
        风险：需显式释放（如`IDisposable`接口、`using`语句），否则导致内存泄漏。

        高频堆（High-Frequency Heap/Loader Heap）
        存储内容：
            - 类型元数据、方法表、静态变量。
            - 常量（编译时确定的值）。
        特点：
            - 生命周期与应用程序域（AppDomain）绑定，不会被GC回收。
    4、其他内存区域
        代码段：JIT编译后的本地代码。
        应用程序域（AppDomain）：逻辑隔离单元，静态变量在各自AppDomain独立。
    5、特殊场景
        字符串驻留（Interning）：`string`字面量存入进程级的池，避免重复。
        结构体（Struct）：
            - 默认栈分配，若嵌入类中则存于堆。
            - 显式内存布局可通过`StructLayout`定制（如与非托管代码交互）。
    6、内存管理注意事项
        GC优化：短生命周期对象应避免晋升到Gen 2。
        内存泄漏：
            - 静态集合长期持有对象引用。
            - 未释放非托管资源（需实现`IDisposable`）。
        性能权衡：值类型减少堆分配，但需避免过度装箱。

## NetFramework升级NetCore 8的经验

    1、VS自带的项目升级
    2、基础框架修改为netstandard2.0
    3、处理包引用、ASPCore不兼容的地方、数据库不兼容的地方
    4、优化跨平台的发包方式

##  list、hashset 

    当然，`List` 和 `HashSet` 是常见的数据结构，它们在不同的编程语言中都有实现。以下是对它们的详细介绍，包括它们的原理和特点。
    1. List
        `List` 是一种线性数据结构，用于存储有序的元素集合。它可以动态扩展或缩小，以适应元素数量的变化。
        特点
        - 有序性：元素按照插入顺序排列。
        - 允许重复：可以存储重复的元素。
        - 支持索引访问：可以通过索引快速访问或修改元素。
        - 动态扩展：可以根据需要自动调整大小。
        实现原理
        - 基于数组的实现（如 ArrayList）：
        - 内部使用一个动态数组来存储元素。
        - 当数组容量不足时，会创建一个更大的数组，并将原有元素复制到新数组中。
        - 插入和删除操作在数组中间位置时效率较低，因为需要移动大量元素。
        - 基于链表的实现（如 LinkedList）：
        - 内部使用双向链表来存储元素。
        - 每个节点包含一个元素和两个指针（指向前后节点）。
        - 插入和删除操作在链表中间位置时效率较高，因为只需调整指针即可。
        适用场景
        - ArrayList：适合需要频繁随机访问的场景，如需要按索引快速查找或修改元素。
        - LinkedList：适合需要频繁插入和删除的场景，如频繁在列表中间插入或删除元素。
    1. HashSet
        `HashSet` 是一种基于哈希表的集合数据结构，用于存储无序的、唯一的元素集合。
        特点
        - 无序性：元素没有固定的顺序。
        - 唯一性：不允许存储重复的元素。
        - 快速查找：通过哈希函数实现高效的查找、插入和删除操作。
        实现原理
        - 基于哈希表：
        - 内部使用一个哈希表来存储元素。
        - 每个元素通过哈希函数计算出一个哈希值，该哈希值决定了元素在哈希表中的存储位置（称为“桶”）。
        - 如果两个元素的哈希值相同（称为“哈希冲突”），通常使用链表或开放寻址法来解决冲突。
        - 哈希冲突解决方法：
        - 链表法：每个桶存储一个链表，冲突的元素被存储在同一个链表中。
        - 开放寻址法：当发生冲突时，按照某种探测规则（如线性探测）寻找下一个可用的桶。
        适用场景
        - 需要快速判断某个元素是否存在。
        - 需要存储唯一值的集合。
        - 不关心元素的顺序。
    总结
    - List：适合需要有序存储和频繁随机访问的场景。
    - HashSet：适合需要快速查找和存储唯一值的场景。

## 如何维护线程安全？ concurrentbag 类做法是怎么样的？

    1. 线程安全的维护
        在多线程编程中，维护线程安全是确保数据一致性的重要任务。以下是常见的线程安全维护方法：
        - 锁机制：通过 `lock` 或 `Monitor` 确保同一时间只有一个线程访问共享资源。
        - 无锁编程：使用原子操作（如 `Interlocked`）避免锁的开销。
        - 线程本地存储：每个线程独立操作自己的数据，减少竞争。
        - 不可变性：使用不可变对象确保线程安全。
        - 线程安全集合：使用专门设计的线程安全集合类（如 `ConcurrentBag`）。
    2. `ConcurrentBag` 的实现原理
        `ConcurrentBag` 是 .NET 提供的一种线程安全的集合类，专为多线程场景设计。它的主要特点和实现原理如下：
        - 无序性：`ConcurrentBag` 不保证元素的插入顺序，`TryTake` 方法可能返回任意元素。
        - 线程安全：通过线程本地存储（Thread-Local Storage）实现高效并发。每个线程维护自己的局部队列，减少跨线程竞争。
        - 工作窃取：当一个线程的局部队列为空时，它可以从其他线程的队列中“窃取”任务，提高 CPU 利用率。
        - 无锁设计：内部使用无锁技术（如原子操作）确保高性能。
       1. 典型应用场景
          - 工作窃取模式：多个线程共享任务池，空闲线程从其他线程的任务队列中窃取任务。
          - 临时数据收集：并行计算中，各线程生成的中间结果可以安全地添加到 `ConcurrentBag` 中。
       2. 注意事项
          - 无序性：`ConcurrentBag` 不保证元素顺序，适合不需要顺序的场景。
          - 性能权衡：在频繁跨线程操作的场景中，可能不如 `ConcurrentQueue` 或 `ConcurrentStack` 高效。
          - 空集合处理：`TryTake` 可能失败，需结合循环或超时机制。

## async和await的趣事

    该类用来启动WebSocket客户端，启动时，第一个为和服务循环检测，保持链接，第二个为循环接受消息，在没有连接的时候，跳过本次接受。以前用的Thread，升级到信创后，修改为async的方式，启动上面的2个异步操作。但是，当服务不在线的时候，客户端连接失败，接受消息方法中，先会判断连接是否打开，没有打开，直接进行下一个循环(因为没有进入await client.ReceiveAsync()，堆栈没有返回)，导致启动时，程序卡主。

## async/await

    异步方法的生命周期可以分为以下几个阶段：
        1、初始化：创建状态机实例，初始化状态和任务构建器。
        2、开始执行：调用 Start 方法开始执行异步方法。
        3、执行方法体：在 MoveNext 方法中，根据当前状态执行相应的代码。
        4、遇到 await：检查任务是否完成，如果未完成则注册回调并暂停方法执行。
        5、任务完成：回调被触发，重新调用 MoveNext 方法，恢复异步方法的执行。
        6、方法完成：所有异步操作完成，设置任务的结果或异常。
    这导致await看似是阻塞，实则是回调。

## valuetask

    1、值类型
    2、很多限制，最好只是在await立等结果的地方使用。
    3、一般不使用，在大量的循环中为了性能可能使用。(Task为引用类型，会创建大量的对象在堆上，导致GC压力)

## 什么是 async io,在.net 上表现形式是什么

    什么是异步IO？
        异步IO（Asynchronous I/O）是一种用于优化I/O操作的技术，它允许程序在等待I/O操作完成时不阻塞线程，从而提高系统的响应能力和吞吐量。与传统的同步I/O操作不同，异步I/O操作不会阻塞调用线程，而是在线程等待I/O操作完成时释放线程资源，让线程去执行其他任务。当I/O操作完成时，系统会通知程序，程序可以继续处理结果。
    在.NET上的表现形式
        在.NET中，异步IO主要通过async和await关键字来实现，这些关键字是C#异步编程的核心。从.NET Framework 4.5开始，I/O类型包括了异步方法，以简化异步操作。这些异步方法在其名称中包括Async，例如ReadAsync、WriteAsync、CopyToAsync、FlushAsync、ReadLineAsync和ReadToEndAsync等。

## iocp、epoll

    epoll
        linux使用，通知你来处理任务，回调状态。
    iocp
        win使用，任务完成后，通知你来接受，回调任务。

## 如何将一段内存数据转换为 struct

    Marshal

## GC

    1、模式
        一、工作站模式
            垃圾回收的频率较高，但每次回收的停顿时间较短。
            垃圾回收直接在触发回收的用户线程上执行，与其他用户线程竞争 CPU 时间。
            只分配一个 GC 堆，因此内存分配较少
        二、 服务器模式
            垃圾回收的频率较低，减少停顿时间。
            为每个 CPU 核心分配一个独立的 GC 堆和专用线程，提高吞吐量和性能。
            通常分配更大的内存分段，适合多核心系统
    2、子模式
        后台模式（Background GC）：
            使用专用线程回收第 2 代对象，回收时不会挂起其他线程。
            适用于需要减少停顿时间的场景。
        非并发模式（Non-Concurrent GC）：
            垃圾回收时会挂起所有其他线程，适用于对停顿时间要求不高的场景
    3、抑制GC回收
        GC.TryStartNoGCRegion
    4、查看GC的数量
        Windebug
    5、GC堆的种类
        0、1、2代，以及大对象堆
        分类主要是为了快速回收内存，降低卡顿。生命周期短的对象，在0代被快速回收，生命周期长的进入1、2代，降低0代的数量，增加回收效率。

## 终结器

    终结器（Finalizer）是一种在垃圾回收过程中自动调用的方法，用于执行清理工作。它允许开发者在对象被垃圾回收器回收之前，释放系统资源、关闭文件、断开数据库连接等。
    使用场景
        终结器主要用于释放非托管资源，如文件句柄、数据库连接等。这些资源需要显式的清理，而垃圾回收器不知道如何处理它们。
    使用问题
        执行时间不确定：终结器的执行时间由垃圾回收器决定，无法保证及时性。这可能导致资源释放延迟。
        不能显式调用：终结器只能由垃圾回收器调用，开发者无法控制其执行时间。
        未捕获异常：终结器中抛出的未捕获异常会被忽略，这可能导致程序状态不一致。
        性能开销：终结器的使用会增加垃圾回收的复杂性，降低回收效率。
        安全问题：终结器可能受到终结器攻击，导致恶意子类记录部分构造对象的引用，从而引发安全问题。
    替代方案
        确定性终结：通过实现 IDisposable 接口，显式调用 Dispose 方法来释放资源。
        try-finally 或 try-with-resources：确保资源在异常情况下也能被正确释放。

## 