# 目的

    追求系统的低耦合高内聚。

# 创建型模式

    对象的创建过程，旨在将对象的创建与使用分离，从而降低系统的耦合度。以下是几种创建型模式。
    汇总：
        工厂模式（Factory）、创建者模式（Builder）、单例模式、原型模式(Clone)

## 工厂模式（Factory）

    介绍：
        一个接口的多个类型。
    实现:
        一个接口，多个实现类，在类的属性上标注该【实现类的类型】。通过反射获取该接口的实现类列表,再通过属性获取【实现类的类型】，工厂创建时，如果字符串和实现类的类型相同，则反射创建该类。

## 创建者模式（Builder）

    介绍：
        一个类型的多种构造方式。
        1、主要是为了隐藏目的类的复杂的构造方式。
        2、可以有多个创建者实现该类的不同默认值的类。
        3、建造者一般是链式调用。
    实现：
        先通过CreateBuilder获得具体的Builder，再通过Builder链式调用，设置不同的属性，再Build创建具体的对象。

## 单例模式

## 原型模式(Clone)

    原型模式用一个原型对象来指明所要创建的对象类型，然后用复制这个原型对象的方法来创建出更多的同类型对象。就是C#中的Clone。

# 结构型模式

    主要用于处理类或对象的组合。以下是几种结构型模式。
    汇总：
        适配器模式(SDKWrapper)、装饰者模式(GZipStream)、代理模式、外观模式、桥接模式(BLL)、组合模式(Winform中的控件，都使用OnPaint去绘制)、享元模式(引用类型)

## 适配器模式(SDKWrapper)

    介绍：
        将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。 其 别名为包装器 (Wrapper)。
        适配器模式是将一个对象包装起来以改变其接口，而外观模式是将一群对象 ”包装“起来以简化其接口。它们的意图是不一样的，适配器是将接口转换为不同接口，而外观模式是提供一个统一的接口来简化接口。
    实现：
        就用另外一个接口的实现类包装下接口。接入SDK的时候，使用的SDKWrapper就是适配器模式。

## 装饰者模式(GZipStream)

    介绍：
        装饰者模式采用对象组合而非继承的方式实现了再运行时动态地扩展对象功能的能力，而且可以根据需要扩展多个功能，避免了单独使用继承带来的 ”灵活性差“和”多子类衍生问题“。
    实现:
        把对象组合到装饰者中，对象做为属性，被装饰者操作，添加对象的能力。

## 代理模式

    介绍：
        代理模式就是使用代理把被代理与用户隔离，代理把被代理有相同接口，代理比被代理多做一些不方便做的事。

## 外观模式

    介绍：
        适配器模式是将一个对象包装起来以改变其接口，而外观模式是将一群对象 ”包装“起来以简化其接口。它们的意图是不一样的，适配器是将接口转换为不同接口，而外观模式是提供一个统一的接口来简化接口。

## 桥接模式(BLL)

    介绍：
        桥接模式即将抽象部分与实现部分脱耦，使它们可以独立变化。
    实现：
        三层模式中的BLL就是桥接模式，为DAL的桥接。DAL是数据库的实现，BLL操作DAL，还可以实现其他业务。

## 组合模式(Winform中的控件，都使用OnPaint去绘制)

    介绍：
        组合是一种将多个对象组合成一个更复杂对象的设计模式。允许你将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。在以下情况下应该考虑使用组合模式：
            1、需要表示一个对象整体或部分的层次结构。
            2、希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
    实现：
        就是把同一个接口的多个类型的实现的对象，添加到一个对象，然后统一调用方法。在.NET类库中，都为这两个平台提供了很多现有的控件，然而System.Windows.Forms.dll中System.Windows.Forms.Control类就应用了组合模式，因为控件包括Label、TextBox等这样的简单控件，同时也包括GroupBox、DataGrid这样复合的控件，每个控件都需要调用OnPaint方法来进行控件显示，为了表示这种对象之间整体与部分的层次结构，微软把Control类的实现应用了组合模式

## 享元模式(引用类型)

    介绍：
        共用元数据
    实现：
        c#的引用对象就是享元模式

# 行为型模式

    它关注对象之间的职责分配。它们不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。行为型模式通过定义对象间的通信方式，以及如何分配职责，使得系统设计更加清晰，同时也提高了系统的灵活性和可扩展性。以下是几种行为型模型。
    汇总：
        策略模式（List的排序，使用到了对象的IComparer接口）、模板方法模式（基类实现了一些通用的方法）、观察者模式（delegate）、迭代器模式（IEnumerator）、责任链模式（ASP.NET Core 中的管道）、命令模式（wpf中的ICommand）、备忘录模式（git）、状态模式、访问者模式（静态扩展方法的类）、中介者模式、解释器模式（LINQ）

## 策略模式（List的排序，使用到了对象的IComparer接口）

    介绍：
        对算法（策略）的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。
    实现：
        List的排序，使用到了对象(策略类)的IComparer接口。

## 模板方法模式（基类实现了一些通用的方法）

    介绍：
        在一个抽象类中定义一个操作中的算法骨架（对应于生活中的大家下载的模板），而将一些步骤延迟到子类中去实现（对应于我们根据自己的情况向模板填充内容）。
    实现：
        基类实现了一些通用的方法，则为模板方法模式。

## 观察者模式（delegate）

    介绍：
        一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。
    实现：
        事件就是观察者模式，被观察者发生了变化，多个观察者会收到变化的通知。

## 迭代器模式（IEnumerator）

    介绍：
        提供了一种方法顺序访问一个聚合对象（理解为集合对象）中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。
    实现：
        继承IEnumerator的列表，都使用了迭代器模式。

## 责任链模式（ASP.NET Core 中的管道）

    介绍：
        某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。
    实现：
        ASP.NET Core 中的管道

## 命令模式（wpf中的ICommand）

    介绍：
        一个操作或者行为抽象为一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。
    实现：
        wpf中的ICommand，抽象了Execute、CanExecute、CanExecuteChanged等方法。

## 备忘录模式（git）

    介绍：
        对某个类的状态进行保存下来，等到需要恢复的时候，可以从备忘录中进行恢复。在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。
    实现：
        git就是备忘录模式的复杂版本。

## 状态模式
    
    介绍：
        允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。
    实现：
        一个对象，内部有个状态基类对象/接口，在不同的状态（基类）中切换，对象方法中封装状态的方法，状态切换时，调用对象方法就能够调用到对应的状态的方法。

## 访问者模式（静态扩展方法的类）

    介绍：
        封装一些施加于某种数据结构之上的操作。适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。
    实现：
        静态扩展方法的类，就是访问者。
        
## 中介者模式

    介绍：
        中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。
    实现：
        一些列对象之间相互操作，在中介者中实现操作逻辑，就是中介者模式。

## 解释器模式（LINQ）

    介绍：
        一种行为型设计模式，用于定义一种语言的语法表示，并提供一个解释器来解释这些语法。它通常用于构建简单的语言处理器或解析器，将特定的业务规则转化为代码可理解的语法结构。
    实现：
        LINQ使用表达式来表示查询操作。这些表达式树可以被不同的LINQ提供程序解释和执行。